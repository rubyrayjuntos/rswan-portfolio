import React, { useState, useEffect, useRef, useCallback } from 'react';

// Main App component
const App = () => {
    const [uploadedHtmlContent, setUploadedHtmlContent] = useState('');
    const [analysisResults, setAnalysisResults] = useState(null);
    const [isLoading, setIsLoading] = useState(false);
    const [errorMessage, setErrorMessage] = useState('');
    const [llmCodeSuggestion, setLlmCodeSuggestion] = useState('');
    const [llmAccessibilityExplanation, setLlmAccessibilityExplanation] = useState('');
    const [llmLoading, setLlmLoading] = useState(false);
    const [showHelp, setShowHelp] = useState(false); // State for help modal
    const [isHtml2PdfLoaded, setIsHtml2PdfLoaded] = useState(false); // New state for html2pdf loading
    const contentRef = useRef(null); // Ref for the content to be printed
    const dropAreaRef = useRef(null); // Ref for the drag and drop area

    // Pre-defined example HTML content
    const exampleHtml = {
        cssOnly: `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSS-Only Parallax Example</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: 'Inter', sans-serif;
            color: white;
            overflow: hidden; /* Hide body scrollbar */
        }
        .parallax-container {
            height: 100vh;
            overflow-x: hidden;
            overflow-y: auto; /* Enables scrolling */
            perspective: 1px; /* Defines the 3D depth */
            perspective-origin: 50% 50%;
        }
        .parallax-group {
            position: relative;
            height: 100vh;
            transform-style: preserve-3d; /* Crucial for 3D children */
        }
        .parallax-layer {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .parallax-layer.base {
            background: linear-gradient(to bottom right, #4A00E0, #8E2DE2);
            transform: translateZ(0); /* Stays at the base */
            z-index: 4;
        }
        .parallax-layer.back {
            background: url('https://placehold.co/1200x800/2C006C/FFFFFF?text=Background') no-repeat center center/cover;
            transform: translateZ(-1px) scale(2); /* Moves slower, scale to compensate */
            z-index: 3;
        }
        .parallax-layer.mid {
            background: url('https://placehold.co/1200x800/6A00A8/FFFFFF?text=Midground') no-repeat center center/cover;
            transform: translateZ(-0.5px) scale(1.5);
            z-index: 2;
        }
        .parallax-layer.front {
            background-color: rgba(0,0,0,0.3); /* Semi-transparent overlay */
            transform: translateZ(0.5px) scale(0.5); /* Moves faster, scale to compensate */
            z-index: 5; /* Appears in front of content */
        }
        .content-section {
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            background-color: #1a1a2e;
            z-index: 10; /* Ensures content is always on top */
            position: relative;
            padding: 20px;
            box-sizing: border-box;
        }
        .content-section:nth-child(even) {
             background-color: #0f0f1a;
        }

        /* Accessibility: prefers-reduced-motion */
        @media (prefers-reduced-motion: reduce) {
            .parallax-layer {
                transform: none !important;
                transition: none !important;
                animation: none !important;
            }
            .parallax-group {
                transform-style: flat;
            }
            .parallax-layer.back, .parallax-layer.mid, .parallax-layer.front {
                background: none; /* Remove background images for reduced motion */
                background-color: transparent;
            }
            .parallax-layer.base {
                background: linear-gradient(to bottom right, #4A00E0, #8E2DE2); /* Keep base background */
            }
        }
    </style>
</head>
<body>
    <div class="parallax-container">
        <div class="parallax-group">
            <div class="parallax-layer base"><h1>Base Layer</h1></div>
            <div class="parallax-layer back"></div>
            <div class="parallax-layer mid"></div>
            <div class="parallax-layer front"></div>
        </div>
        <div class="content-section">
            <h2>Scroll down for more content!</h2>
        </div>
        <div class="content-section">
            <h2>This is your main content area.</h2>
        </div>
        <div class="content-section">
            <h2>Enjoy the CSS-only parallax effect.</h2>
        </div>
    </div>
</body>
</html>`,
        jsScroll: `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Scroll Parallax Example</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 200vh; /* Make page scrollable */
            font-family: 'Inter', sans-serif;
            color: white;
            background-color: #1a1a2e;
        }
        .parallax-section {
            position: relative;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .parallax-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('https://placehold.co/1200x800/003366/FFFFFF?text=Background') no-repeat center center/cover;
            will-change: transform; /* Performance hint */
            z-index: 1;
        }
        .parallax-foreground {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* Center initially */
            font-size: 1.5em;
            will-change: transform; /* Performance hint */
            z-index: 3;
            background-color: rgba(0,0,0,0.4);
            padding: 20px 40px;
            border-radius: 10px;
        }
        .content-area {
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #0f0f1a;
            font-size: 1.8em;
            text-align: center;
            z-index: 2; /* Below foreground, above background */
            position: relative;
        }

        /* Accessibility: prefers-reduced-motion */
        @media (prefers-reduced-motion: reduce) {
            .parallax-background, .parallax-foreground {
                transform: none !important;
                transition: none !important;
                animation: none !important;
            }
            .parallax-background {
                background-attachment: scroll !important; /* Disable fixed background */
            }
        }
    </style>
</head>
<body>
    <div class="parallax-section">
        <div class="parallax-background" data-speed="0.5"></div>
        <div class="parallax-foreground" data-speed="1.2">JS Scroll Parallax</div>
    </div>
    <div class="content-area">
        <p>Scroll down to see the effect!</p>
    </div>
    <div class="content-area">
        <p>This content is static relative to the viewport.</p>
    </div>

    <script>
        const background = document.querySelector('.parallax-background');
        const foreground = document.querySelector('.parallax-foreground');

        let scrollPos = 0;
        let ticking = false;

        function updateParallax() {
            const bgSpeed = parseFloat(background.dataset.speed);
            const fgSpeed = parseFloat(foreground.dataset.speed);

            const bgY = scrollPos * bgSpeed;
            const fgY = scrollPos * fgSpeed;

            background.style.transform = \`translate3d(0, \${bgY}px, 0)\`;
            foreground.style.transform = \`translate3d(-50%, calc(-50% + \${fgY}px), 0)\`; // Keep centered horizontally

            ticking = false;
        }

        window.addEventListener('scroll', () => {
            scrollPos = window.scrollY;
            if (!ticking) {
                window.requestAnimationFrame(updateParallax);
                ticking = true;
            }
        });
        // Initial call
        updateParallax();
    </script>
</body>
</html>`,
        jsMouse: `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Mouse Parallax Example</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #2a2a4a;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .mouse-parallax-area {
            position: relative;
            width: 80vw;
            height: 80vh;
            background: linear-gradient(to bottom right, #5C258D, #4389A2);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            overflow: hidden; /* Keep elements inside */
            display: flex;
            align-items: center;
            justify-content: center;
            perspective: 1000px; /* For 3D tilt effect */
            transform-style: preserve-3d;
        }
        .parallax-element {
            position: absolute;
            will-change: transform;
            transition: transform 0.1s ease-out; /* Smooth transition for subtle movements */
            text-align: center;
            color: white;
            padding: 15px;
            border-radius: 10px;
        }
        .element-1 {
            font-size: 3em;
            font-weight: bold;
            data-depth: "0.05"; /* Added data-depth for analysis */
            transform: translateZ(50px); /* Closer */
            background-color: rgba(255,255,255,0.1);
        }
        .element-2 {
            font-size: 1.5em;
            top: 20%;
            left: 15%;
            data-depth: "0.03"; /* Added data-depth for analysis */
            transform: translateZ(20px); /* Mid-ground */
            background-color: rgba(0,0,0,0.2);
        }
        .element-3 {
            font-size: 1.2em;
            bottom: 10%;
            right: 10%;
            data-depth: "0.07"; /* Added data-depth for analysis */
            transform: translateZ(80px); /* Closest */
            background-color: rgba(255,255,255,0.05);
        }

        /* Accessibility: prefers-reduced-motion */
        @media (prefers-reduced-motion: reduce) {
            .parallax-element {
                transform: none !important;
                transition: none !important;
                animation: none !important;
            }
        }
    </style>
</head>
<body>
    <div class="mouse-parallax-area">
        <div class="parallax-element element-1" data-depth="0.05">Interactive Parallax</div>
        <div class="parallax-element element-2" data-depth="0.03">Move your mouse!</div>
        <div class="parallax-element element-3" data-depth="0.07">Depth Effect</div>
    </div>

    <script>
        const parallaxArea = document.querySelector('.mouse-parallax-area');
        const parallaxElements = document.querySelectorAll('.parallax-element');

        // Check for reduced motion preference
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

        if (!prefersReducedMotion) {
            parallaxArea.addEventListener('mousemove', (e) => {
                const rect = parallaxArea.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                const mouseX = e.clientX - centerX;
                const mouseY = e.clientY - centerY;

                window.requestAnimationFrame(() => {
                    parallaxElements.forEach(element => {
                        const depth = parseFloat(element.dataset.depth);
                        const xMove = -mouseX * depth;
                        const yMove = -mouseY * depth;
                        // Apply both translate3d and rotate for a more pronounced 3D effect
                        element.style.transform = \`translate3d(\${xMove}px, \${yMove}px, \${element.style.transform.match(/translateZ\\(([^)]+)\\)/)?.[1] || '0'}) rotateX(\${yMove / 50}deg) rotateY(\${-mouseX / 50}deg)\`;
                    });
                });
            });

            // Disable mouse parallax on touch devices
            parallaxArea.addEventListener('touchstart', () => {
                parallaxArea.removeEventListener('mousemove', handleMouseMove); // Remove mousemove listener
                parallaxElements.forEach(element => {
                    element.style.transform = \`translate3d(0, 0, \${element.style.transform.match(/translateZ\\(([^)]+)\\)/)?.[1] || '0'})\`; // Reset position
                });
            }, { once: true }); // Only listen once to detect touch
        }

        function handleMouseMove(e) {
            const rect = parallaxArea.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const mouseX = e.clientX - centerX;
            const mouseY = e.clientY - centerY;

            window.requestAnimationFrame(() => {
                parallaxElements.forEach(element => {
                    const depth = parseFloat(element.dataset.depth);
                    const xMove = -mouseX * depth;
                    const yMove = -mouseY * depth;
                    element.style.transform = \`translate3d(\${xMove}px, \${yMove}px, \${element.style.transform.match(/translateZ\\(([^)]+)\\)/)?.[1] || '0'}) rotateX(\${yMove / 50}deg) rotateY(\${-mouseX / 50}deg)\`;
                });
            });
        }
    </script>
</body>
</html>`
    };

    // Effect to dynamically load html2pdf.js
    useEffect(() => {
        if (window.html2pdf) {
            setIsHtml2PdfLoaded(true);
            return;
        }

        const script = document.createElement('script');
        script.src = "https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js";
        script.async = true;
        script.onload = () => setIsHtml2PdfLoaded(true);
        script.onerror = () => {
            console.error('Failed to load html2pdf.js');
            // Optionally, set an error state for the user
        };
        document.body.appendChild(script);

        return () => {
            // Clean up the script if the component unmounts
            if (document.body.contains(script)) {
                document.body.removeChild(script);
            }
        };
    }, []); // Empty dependency array means this runs once on mount


    // Function to handle file upload
    const handleFileUpload = (file) => {
        if (file) {
            if (file.type !== 'text/html') {
                setErrorMessage('Please upload a valid HTML file.');
                setUploadedHtmlContent('');
                setAnalysisResults(null);
                return;
            }
            setErrorMessage('');
            setIsLoading(true);
            setLlmCodeSuggestion(''); // Clear previous LLM suggestions
            setLlmAccessibilityExplanation(''); // Clear previous LLM explanations
            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result;
                setUploadedHtmlContent(content);
                analyzeParallax(content); // Trigger analysis after content is loaded
            };
            reader.onerror = () => {
                setErrorMessage('Failed to read file.');
                setIsLoading(false);
            };
            reader.readAsText(file);
        }
    };

    // Drag and Drop Handlers
    const handleDragOver = useCallback((event) => {
        event.preventDefault();
        event.stopPropagation();
        if (dropAreaRef.current) {
            dropAreaRef.current.classList.add('border-indigo-400', 'bg-gray-600');
        }
    }, []);

    const handleDragLeave = useCallback((event) => {
        event.preventDefault();
        event.stopPropagation();
        if (dropAreaRef.current) {
            dropAreaRef.current.classList.remove('border-indigo-400', 'bg-gray-600');
        }
    }, []);

    const handleDrop = useCallback((event) => {
        event.preventDefault();
        event.stopPropagation();
        if (dropAreaRef.current) {
            dropAreaRef.current.classList.remove('border-indigo-400', 'bg-gray-600');
        }

        const files = event.dataTransfer.files;
        if (files && files.length > 0) {
            handleFileUpload(files[0]);
        }
    }, [handleFileUpload]);


    useEffect(() => {
        const dropArea = dropAreaRef.current;
        if (dropArea) {
            dropArea.addEventListener('dragover', handleDragOver);
            dropArea.addEventListener('dragleave', handleDragLeave);
            dropArea.addEventListener('drop', handleDrop);

            return () => {
                dropArea.removeEventListener('dragover', handleDragOver);
                dropArea.removeEventListener('dragleave', handleDragLeave);
                dropArea.removeEventListener('drop', handleDrop);
            };
        }
    }, [handleDragOver, handleDragLeave, handleDrop]);


    // Main analysis function
    const analyzeParallax = (htmlContent) => {
        const results = {
            cpuUsage: analyzeCpuUsage(htmlContent),
            jsVsCss: analyzeJsVsCss(htmlContent),
            accessibility: analyzeAccessibility(htmlContent),
            responsiveness: analyzeResponsiveness(htmlContent),
            mouseParallax: analyzeMouseParallax(htmlContent),
        };
        setAnalysisResults(results);
        setIsLoading(false);
    };

    // --- Analysis Functions ---

    // Estimates CPU usage based on common patterns
    const analyzeCpuUsage = (htmlContent) => {
        const cpuPoints = [];
        const journeyMarkers = [];
        const detectedLayers = [];
        let estimatedCpuLoad = 0; // Baseline

        // Check for scroll event listeners
        if (htmlContent.includes('window.addEventListener(\'scroll\'') || htmlContent.includes('document.addEventListener(\'scroll\'')) {
            estimatedCpuLoad += 20; // Base load for scroll listener
            journeyMarkers.push('Scroll Listener Detected');

            // Check for common inefficient JS animations (top, left, width, height)
            if (htmlContent.match(/(element|el|item)\.style\.(top|left|width|height)\s*=/g)) {
                estimatedCpuLoad += 30; // High impact
                journeyMarkers.push('Inefficient JS Property Animation (top/left/width/height)');
            }
            // Check for efficient JS animations (transform, opacity)
            if (htmlContent.match(/(element|el|item)\.style\.transform\s*=/g) || htmlContent.includes('transform: ') || htmlContent.includes('opacity: ')) {
                estimatedCpuLoad += 10; // Lower impact
                journeyMarkers.push('Efficient JS Property Animation (transform/opacity)');
            }

            // Detect JS parallax layers and their speeds (simplified)
            const jsLayerMatches = htmlContent.matchAll(/data-speed="([\d\.]+)"[^>]*class="([^"]*)"/g);
            for (const match of jsLayerMatches) {
                detectedLayers.push({
                    type: 'JS',
                    class: match[2],
                    speed: parseFloat(match[1])
                });
            }
        }

        // Check for CSS-only parallax indicators
        if (htmlContent.includes('perspective:') && htmlContent.includes('transform-style: preserve-3d') && htmlContent.includes('translateZ(')) {
            estimatedCpuLoad += 5; // Very low impact for CSS-only
            journeyMarkers.push('CSS-Only Parallax Detected');

            // Detect CSS parallax layers and their depths (simplified)
            const cssLayerMatches = htmlContent.matchAll(/transform:\s*translateZ\(([^)]+)\)\s*scale\(([^)]+)\)[^}]*class="([^"]*)"/g);
            for (const match of cssLayerMatches) {
                detectedLayers.push({
                    type: 'CSS',
                    class: match[3],
                    translateZ: match[1],
                    scale: parseFloat(match[2])
                });
            }
        }

        // Simulate a journey with varying CPU load
        // This is a conceptual representation, not actual measurement
        for (let i = 0; i < 10; i++) {
            cpuPoints.push(Math.max(5, estimatedCpuLoad + Math.random() * 20 - 10)); // Add some variance
        }

        return { cpuPoints, journeyMarkers, detectedLayers };
    };

    // Compares JavaScript-controlled effects with potential CSS transform alternatives
    const analyzeJsVsCss = (htmlContent) => {
        const findings = [];

        // Regex to find common JS scroll-based animations that modify layout properties
        const inefficientJsPatterns = [
            {
                regex: /window\.scrollY.*\.style\.top\s*=/s,
                description: 'JavaScript modifying `top` property on scroll.',
                cssAlternative: 'Consider using `transform: translateY()` with CSS or JavaScript for better performance.',
                snippetContext: htmlContent.match(/window\.scrollY.*\.style\.top\s*=[^;]+/s)?.[0] || 'Snippet not found.',
            },
            {
                regex: /window\.scrollY.*\.style\.left\s*=/s,
                description: 'JavaScript modifying `left` property on scroll.',
                cssAlternative: 'Consider using `transform: translateX()` with CSS or JavaScript for better performance.',
                snippetContext: htmlContent.match(/window\.scrollY.*\.style\.left\s*=[^;]+/s)?.[0] || 'Snippet not found.',
            },
            {
                regex: /window\.scrollY.*\.style\.width\s*=/s,
                description: 'JavaScript modifying `width` property on scroll.',
                cssAlternative: 'Consider using `transform: scaleX()` or CSS `width` with `will-change` where appropriate.',
                snippetContext: htmlContent.match(/window\.scrollY.*\.style\.width\s*=[^;]+/s)?.[0] || 'Snippet not found.',
            },
            {
                regex: /window\.scrollY.*\.style\.height\s*=/s,
                description: 'JavaScript modifying `height` property on scroll.',
                cssAlternative: 'Consider using `transform: scaleY()` or CSS `height` with `will-change` where appropriate.',
                snippetContext: htmlContent.match(/window\.scrollY.*\.style\.height\s*=[^;]+/s)?.[0] || 'Snippet not found.',
            },
        ];

        inefficientJsPatterns.forEach(pattern => {
            if (htmlContent.match(pattern.regex)) {
                findings.push({
                    type: 'X',
                    description: pattern.description,
                    suggestion: pattern.cssAlternative,
                    context: pattern.snippetContext, // Store the snippet for LLM
                    llmFeature: true,
                });
            }
        });

        // Check for `will-change: transform` hint in CSS
        if (!htmlContent.includes('will-change: transform')) {
            findings.push({
                type: 'X',
                description: 'Missing `will-change: transform` on animated elements.',
                suggestion: 'Add `will-change: transform` to elements that are actively animated to hint to the browser for optimization.',
                llmFeature: false, // No LLM for this specific one, as it's a simple fix
            });
        } else {
             findings.push({
                type: 'O',
                description: '`will-change: transform` detected.',
                suggestion: 'Good practice for performance optimization.',
                llmFeature: false,
            });
        }

        // Check for `requestAnimationFrame` usage in JS
        if (!htmlContent.includes('requestAnimationFrame(')) {
            findings.push({
                type: 'X',
                description: '`requestAnimationFrame` not detected for animations.',
                suggestion: 'Use `requestAnimationFrame` to synchronize animations with browser refresh rate for smoother performance.',
                llmFeature: false, // No LLM for this specific one, as it's a simple fix
            });
        } else {
             findings.push({
                type: 'O',
                description: '`requestAnimationFrame` detected for animations.',
                suggestion: 'Good practice for smooth animations.',
                llmFeature: false,
            });
        }

        if (findings.filter(f => f.type === 'X').length === 0) {
            findings.push({
                type: 'O',
                description: 'No obvious inefficient JavaScript animations detected. Looks good!',
                suggestion: '',
                llmFeature: false,
            });
        }

        return findings;
    };

    // Assesses accessibility aspects
    const analyzeAccessibility = (htmlContent) => {
        const findings = [];
        let score = 100; // Start with a perfect score

        // Check for prefers-reduced-motion media query
        if (!htmlContent.includes('@media (prefers-reduced-motion: reduce)')) {
            findings.push({
                type: 'X',
                description: '`prefers-reduced-motion` media query not detected.',
                suggestion: 'Implement `@media (prefers-reduced-motion: reduce)` to disable or reduce motion for users who prefer it.',
                llmFeature: true, // Enable LLM for this
            });
            score -= 30; // Deduct points for missing critical accessibility feature
        } else {
            findings.push({
                type: 'O',
                description: '`prefers-reduced-motion` media query detected.',
                suggestion: 'Good practice for accessibility.',
                llmFeature: false,
            });
        }

        // Suggest a user toggle (hard to detect if already present without complex parsing)
        findings.push({
            type: 'Suggestion',
            description: 'Consider adding a user toggle to manually disable/enable parallax effects.',
            suggestion: 'Provides direct control for users beyond system settings.',
            llmFeature: false,
        });

        // General readability suggestion
        findings.push({
            type: 'Suggestion',
            description: 'Ensure content readability on top of moving backgrounds.',
            suggestion: 'Use sufficient contrast, text shadows, or semi-transparent overlays to ensure text is always legible.',
            llmFeature: false,
        });

        // Ensure score doesn't go below 0
        score = Math.max(0, score);
        return { findings, score };
    };

    // Assesses responsiveness based on media queries
    const analyzeResponsiveness = (htmlContent) => {
        const scores = {
            computer: 'N/A', // Default to N/A, assuming desktop-first unless mobile queries are strong
            tablet: 'Needs Assessment',
            phone: 'Needs Assessment',
        };

        let foundMobileQuery = false;
        let foundTabletQuery = false;

        // Check for common mobile breakpoints
        if (htmlContent.includes('@media (max-width: 767px)') || htmlContent.includes('@media screen and (max-width: 767px)')) {
            foundMobileQuery = true;
        }
        if (htmlContent.includes('@media (max-width: 480px)') || htmlContent.includes('@media screen and (max-width: 480px)')) {
            foundMobileQuery = true;
        }

        // Check for common tablet breakpoints
        if (htmlContent.includes('@media (min-width: 768px) and (max-width: 1024px)')) {
            foundTabletQuery = true;
        }
        if (htmlContent.includes('@media (max-width: 1024px)') && !foundMobileQuery) { // Broader tablet
            foundTabletQuery = true;
        }

        // Check for viewport meta tag
        if (!htmlContent.includes('<meta name="viewport" content="width=device-width, initial-scale=1.0">')) {
            scores.phone = 'Poor (Missing Viewport Meta Tag)';
            scores.tablet = 'Poor (Missing Viewport Meta Tag)';
            scores.computer = 'Potentially Affected (Missing Viewport Meta Tag)';
        } else {
            if (foundMobileQuery) {
                scores.phone = 'Good (Mobile Media Queries Detected)';
            } else {
                scores.phone = 'Fair (No Specific Mobile Media Queries Detected)';
            }

            if (foundTabletQuery) {
                scores.tablet = 'Good (Tablet Media Queries Detected)';
            } else {
                scores.tablet = 'Fair (No Specific Tablet Media Queries Detected)';
            }
            scores.computer = 'Good (Viewport Meta Tag Present)';
        }

        return scores;
    };

    // Assesses mouse parallax effects on mobile
    const analyzeMouseParallax = (htmlContent) => {
        const findings = [];
        let mouseParallaxDetected = false;

        if (htmlContent.includes('addEventListener(\'mousemove\'')) {
            mouseParallaxDetected = true;
            findings.push({
                type: 'Detected',
                description: 'Mouse parallax effect detected (via `mousemove` listener).',
                suggestion: '',
            });

            // Check for explicit mobile handling (simplified)
            if (htmlContent.includes('if (window.innerWidth <') || htmlContent.includes('if (e.touches)')) {
                findings.push({
                    type: 'O',
                    description: 'Some form of mobile/touch detection found for mouse parallax.',
                    suggestion: 'Good, but further manual testing is recommended for touch device behavior.',
                });
            } else {
                findings.push({
                    type: 'X',
                    description: 'No explicit mobile/touch handling detected for mouse parallax.',
                    suggestion: 'Mouse parallax is ineffective on touch devices. Consider disabling it or providing a touch-based alternative (e.g., gyroscope data, though complex) for mobile.',
                });
            }
        }

        if (!mouseParallaxDetected) {
            findings.push({
                type: 'N/A',
                description: 'No mouse parallax effects detected.',
                suggestion: '',
            });
        }

        return findings;
    };

    // --- LLM Integration Functions ---

    const generateCodeSuggestion = async (description, snippetContext) => {
        setLlmLoading(true);
        setLlmCodeSuggestion('');
        setLlmAccessibilityExplanation(''); // Clear other LLM output

        const prompt = `You are a web performance expert. The following HTML/CSS/JS snippet is causing performance issues due to inefficient parallax animation. Identify the inefficient part and provide a more performant alternative using CSS transforms or requestAnimationFrame if CSS is not sufficient. Explain why your suggestion is better. Provide only the code snippet, no conversational text.

Inefficient snippet:
\`\`\`javascript
${snippetContext}
\`\`\`

Explanation and Optimized Code:`;

        try {
            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };
            const apiKey = ""; // If you want to use models other than gemini-2.0-flash or imagen-3.0-generate-002, provide an API key here. Otherwise, leave this as-is.
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const result = await response.json();

            if (result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
                const text = result.candidates[0].content.parts[0].text;
                setLlmCodeSuggestion(text);
            } else {
                setLlmCodeSuggestion('Failed to generate suggestion. Please try again.');
                console.error('Gemini API response structure unexpected:', result);
            }
        } catch (error) {
            setLlmCodeSuggestion('Error generating suggestion: ' + error.message);
            console.error('Error calling Gemini API:', error);
        } finally {
            setLlmLoading(false);
        }
    };

    const generateAccessibilityExplanation = async (description) => {
        setLlmLoading(true);
        setLlmCodeSuggestion(''); // Clear other LLM output
        setLlmAccessibilityExplanation('');

        const prompt = `You are an accessibility expert. Explain the importance of "${description}" for web accessibility in the context of parallax effects. Also, provide a simple CSS snippet demonstrating how to use prefers-reduced-motion to reduce motion. Keep the explanation concise and the code clear.`;

        try {
            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };
            const apiKey = ""; // If you want to use models other than gemini-2.0-flash or imagen-3.0-generate-002, provide an API key here. Otherwise, leave this as-is.
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const result = await response.json();

            if (result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
                const text = result.candidates[0].content.parts[0].text;
                setLlmAccessibilityExplanation(text);
            } else {
                setLlmAccessibilityExplanation('Failed to generate explanation. Please try again.');
                console.error('Gemini API response structure unexpected:', result);
            }
        } catch (error) {
            setLlmAccessibilityExplanation('Error generating explanation: ' + error.message);
            console.error('Error calling Gemini API:', error);
        } finally {
            setLlmLoading(false);
        }
    };

    // --- PDF Generation Function ---
    const handlePrintPdf = () => {
        if (contentRef.current) {
            // Check if html2pdf is available globally
            if (isHtml2PdfLoaded) {
                const element = contentRef.current;
                const opt = {
                    margin: 0.5,
                    filename: 'parallax_dashboard_report.pdf',
                    image: { type: 'jpeg', quality: 0.98 },
                    html2canvas: { scale: 2, logging: true, dpi: 192, letterRendering: true },
                    jsPDF: { unit: 'in', format: 'letter', orientation: 'portrait' }
                };
                window.html2pdf().set(opt).from(element).save();
            } else {
                // Use a custom message box instead of alert()
                const messageBox = document.createElement('div');
                messageBox.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[9999]';
                messageBox.innerHTML = `
                    <div class="bg-gray-800 p-6 rounded-lg shadow-xl text-white max-w-sm text-center relative">
                        <button class="absolute top-2 right-2 text-gray-400 hover:text-gray-200 text-xl" onclick="this.parentNode.parentNode.remove()">&times;</button>
                        <p class="mb-4">PDF generation library is still loading or failed to load. Please try again in a moment.</p>
                        <button class="px-4 py-2 bg-blue-600 rounded hover:bg-blue-700" onclick="this.parentNode.parentNode.remove()">OK</button>
                    </div>
                `;
                document.body.appendChild(messageBox);
                console.error('html2pdf.js is not loaded yet.');
            }
        } else {
            const messageBox = document.createElement('div');
            messageBox.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[9999]';
            messageBox.innerHTML = `
                <div class="bg-gray-800 p-6 rounded-lg shadow-xl text-white max-w-sm text-center relative">
                    <button class="absolute top-2 right-2 text-gray-400 hover:text-gray-200 text-xl" onclick="this.parentNode.parentNode.remove()">&times;</button>
                    <p class="mb-4">No content to print. Please upload an HTML file first.</p>
                    <button class="px-4 py-2 bg-blue-600 rounded hover:bg-blue-700" onclick="this.parentNode.parentNode.remove()">OK</button>
                </div>
            `;
            document.body.appendChild(messageBox);
        }
    };

    // --- UI Components ---

    // Simple Line Graph for CPU Usage (Conceptual)
    const CpuUsageGraph = ({ data, markers, detectedLayers }) => {
        const svgWidth = 600;
        const svgHeight = 200;
        const padding = 30;
        const maxVal = Math.max(...data);
        const scaleY = (val) => svgHeight - padding - (val / maxVal) * (svgHeight - 2 * padding);
        const scaleX = (idx) => padding + (idx / (data.length - 1)) * (svgWidth - 2 * padding);

        const pathData = data.map((val, i) => `${i === 0 ? 'M' : 'L'}${scaleX(i)},${scaleY(val)}`).join(' ');

        return (
            <div className="bg-gray-800 p-4 rounded-lg shadow-inner">
                <h3 className="text-lg font-semibold mb-2 text-white">Estimated Processor Usage Over Time</h3>
                <p className="text-sm text-gray-400 mb-4">
                    <span className="font-bold text-yellow-400">Note:</span> This is a static estimation based on code patterns, not a live measurement. For actual CPU usage, use browser developer tools.
                </p>
                <svg width={svgWidth} height={svgHeight} className="bg-gray-900 rounded-md">
                    <g>
                        {/* Y-axis */}
                        <line x1={padding} y1={padding} x2={padding} y2={svgHeight - padding} stroke="#6B7280" strokeWidth="1" />
                        {/* X-axis */}
                        <line x1={padding} y1={svgHeight - padding} x2={svgWidth - padding} y2={svgHeight - padding} stroke="#6B7280" strokeWidth="1" />

                        {/* Y-axis labels */}
                        <text x={padding - 5} y={scaleY(maxVal)} textAnchor="end" fill="#9CA3AF" fontSize="10px">High</text>
                        <text x={padding - 5} y={scaleY(maxVal / 2)} textAnchor="end" fill="#9CA3AF" fontSize="10px">Medium</text>
                        <text x={padding - 5} y={scaleY(0)} textAnchor="end" fill="#9CA3AF" fontSize="10px">Low</text>

                        {/* Line */}
                        <path d={pathData} fill="none" stroke="#6366F1" strokeWidth="2" />

                        {/* Markers */}
                        {markers.map((marker, i) => (
                            <circle
                                key={i}
                                cx={scaleX(i * (data.length - 1) / markers.length)} // Distribute markers
                                cy={scaleY(data[Math.floor(i * (data.length - 1) / markers.length)])}
                                r="4"
                                fill="#FCD34D"
                                stroke="#FCD34D"
                                strokeWidth="1"
                            >
                                <title>{marker}</title>
                            </circle>
                        ))}
                    </g>
                </svg>
                <div className="mt-2 text-sm text-gray-400">
                    <p><strong>Journey Markers:</strong></p>
                    <ul className="list-disc list-inside">
                        {markers.map((marker, i) => (
                            <li key={i}>{marker}</li>
                        ))}
                    </ul>
                </div>
                {detectedLayers && detectedLayers.length > 0 && (
                    <div className="mt-4 text-sm text-gray-400">
                        <p><strong>Detected Parallax Layers:</strong></p>
                        <ul className="list-disc list-inside">
                            {detectedLayers.map((layer, i) => (
                                <li key={i}>
                                    {layer.type === 'JS' ?
                                        `JS Layer: .${layer.class || 'Unnamed'} (Speed: ${layer.speed})` :
                                        `CSS Layer: .${layer.class || 'Unnamed'} (TranslateZ: ${layer.translateZ}, Scale: ${layer.scale})`
                                    }
                                </li>
                            ))}
                        </ul>
                    </div>
                )}
            </div>
        );
    };

    // Help Modal Component
    const HelpModal = ({ onClose }) => {
        return (
            <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
                <div className="bg-gray-800 rounded-lg shadow-xl p-8 max-w-2xl w-full relative border border-indigo-600">
                    <button
                        onClick={onClose}
                        className="absolute top-4 right-4 text-gray-400 hover:text-gray-200 text-2xl font-bold"
                    >
                        &times;
                    </button>
                    <h2 className="text-2xl font-bold text-indigo-400 mb-4">How to Use This Dashboard</h2>
                    <div className="text-gray-300 space-y-4 text-sm md:text-base">
                        <p>
                            Welcome to the Parallax Best Practice Metrics Dashboard! This tool helps you analyze the
                            performance, accessibility, and responsiveness of parallax effects in your HTML pages.
                        </p>
                        <h3 className="text-xl font-semibold text-gray-200">1. Upload Your HTML Page</h3>
                        <p>
                            Click the "Upload Your HTML Page for Analysis" button or **drag and drop** your HTML file
                            into the upload area. The dashboard will then automatically process the file.
                            You can also load one of the **pre-defined examples** to see how they are analyzed.
                        </p>
                        <h3 className="text-xl font-semibold text-gray-200">2. Understand the Analysis Results</h3>
                        <ul className="list-disc list-inside space-y-2">
                            <li>
                                <strong>Estimated Processor Usage:</strong> This graph provides a conceptual estimation
                                of CPU load based on detected JavaScript and CSS parallax patterns. It highlights areas
                                where performance might be impacted. Below the graph, you'll see a **list of detected parallax layers**
                                and their characteristics (speed for JS, translateZ/scale for CSS). Remember, this is a static analysis, not a live measurement.
                            </li>
                            <li>
                                <strong>JavaScript vs. CSS Transforms Efficiency:</strong> This section identifies JavaScript-driven
                                animations that could potentially be optimized using more performant CSS transforms. Look for "✕"
                                indicators and "✨ Suggest Optimization" buttons for AI-powered code fixes.
                            </li>
                            <li>
                                <strong>Accessibility Assessment:</strong> Reviews your page for common accessibility practices related to motion,
                                such as the `prefers-reduced-motion` media query. "✕" indicates areas for improvement, and
                                "✨ Explain/Suggest Fix" offers AI-generated explanations and code. An **overall accessibility score**
                                is also provided for a quick overview.
                            </li>
                            <li>
                                <strong>Responsiveness Assessment:</strong> Scores your page's responsiveness across desktop,
                                tablet, and phone breakpoints based on the presence of viewport meta tags and media queries.
                            </li>
                            <li>
                                <strong>Mouse Parallax Effects on Mobile:</strong> Checks if your mouse-controlled parallax
                                effects have appropriate handling for touch devices, as mouse effects are ineffective on mobile.
                            </li>
                        </ul>
                        <h3 className="text-xl font-semibold text-gray-200">3. Generate a PDF Report</h3>
                        <p>
                            After analysis, click the "Print Analysis to PDF" button to download a comprehensive report
                            that you can use as a checklist for optimizing your parallax implementations.
                        </p>
                        <p className="text-center text-gray-400 mt-6">
                            For more detailed insights, consider using your browser's built-in developer tools for live performance profiling.
                        </p>
                    </div>
                </div>
            </div>
        );
    };


    // Render the main dashboard UI
    return (
        <div className="min-h-screen bg-gray-900 text-gray-100 font-inter p-6 flex flex-col items-center">
            <style>
                @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
            </style>

            <div className="w-full max-w-4xl bg-gray-800 rounded-xl shadow-lg p-8 relative"> {/* Added relative for button positioning */}
                <h1 className="text-3xl font-bold text-center mb-6 text-indigo-400">
                    Parallax Best Practice Metrics Dashboard
                </h1>

                {/* Help Button */}
                <button
                    onClick={() => setShowHelp(true)}
                    className="absolute top-4 right-4 px-4 py-2 bg-blue-600 text-white font-semibold rounded-full hover:bg-blue-700 transition duration-200 ease-in-out shadow-md text-sm"
                >
                    Help
                </button>

                <div ref={dropAreaRef} className="mb-8 p-6 bg-gray-700 rounded-lg shadow-md border-2 border-dashed border-gray-500 hover:border-indigo-400 hover:bg-gray-600 transition-all duration-200 ease-in-out text-center cursor-pointer">
                    <label htmlFor="html-upload" className="block text-lg font-semibold mb-3 text-gray-200 cursor-pointer">
                        Drag & Drop your HTML Page here or Click to Upload
                    </label>
                    <input
                        type="file"
                        id="html-upload"
                        accept=".html"
                        onChange={(e) => handleFileUpload(e.target.files[0])}
                        className="hidden" // Hide the default input
                    />
                    <p className="text-sm text-gray-400">Only .html files are supported.</p>
                    {errorMessage && <p className="text-red-400 mt-2 text-sm">{errorMessage}</p>}
                </div>

                {/* Pre-defined Examples */}
                <div className="mb-8 p-6 bg-gray-700 rounded-lg shadow-md">
                    <h2 className="text-xl font-semibold mb-4 text-indigo-300">Load Pre-defined Examples</h2>
                    <div className="flex flex-wrap justify-center gap-4">
                        <div className="flex flex-col items-center">
                            <button
                                onClick={() => handleFileUpload(new Blob([exampleHtml.cssOnly], { type: 'text/html' }))}
                                className="px-4 py-2 bg-purple-600 text-white font-semibold rounded-full hover:bg-purple-700 transition duration-200 ease-in-out shadow-md text-sm"
                            >
                                CSS-Only Parallax
                            </button>
                            <p className="text-xs text-gray-400 mt-2 text-center max-w-xs">
                                Demonstrates a highly performant parallax effect using only CSS 3D transforms.
                            </p>
                        </div>
                        <div className="flex flex-col items-center">
                            <button
                                onClick={() => handleFileUpload(new Blob([exampleHtml.jsScroll], { type: 'text/html' }))}
                                className="px-4 py-2 bg-purple-600 text-white font-semibold rounded-full hover:bg-purple-700 transition duration-200 ease-in-out shadow-md text-sm"
                            >
                                JS Scroll Parallax
                            </button>
                            <p className="text-xs text-gray-400 mt-2 text-center max-w-xs">
                                Shows a scroll-based parallax effect implemented with JavaScript and `requestAnimationFrame`.
                            </p>
                        </div>
                        <div className="flex flex-col items-center">
                            <button
                                onClick={() => handleFileUpload(new Blob([exampleHtml.jsMouse], { type: 'text/html' }))}
                                className="px-4 py-2 bg-purple-600 text-white font-semibold rounded-full hover:bg-purple-700 transition duration-200 ease-in-out shadow-md text-sm"
                            >
                                JS Mouse Parallax
                            </button>
                            <p className="text-xs text-gray-400 mt-2 text-center max-w-xs">
                                Illustrates an interactive parallax effect driven by mouse movement.
                            </p>
                        </div>
                    </div>
                </div>


                {isLoading && (
                    <div className="text-center text-indigo-300 text-lg">
                        Analyzing your page...
                    </div>
                )}

                {analysisResults && (
                    <>
                        <button
                            onClick={handlePrintPdf}
                            disabled={!isHtml2PdfLoaded} // Disable button if html2pdf is not loaded
                            className={`mb-8 px-6 py-2 text-white font-semibold rounded-full transition duration-200 ease-in-out shadow-lg flex items-center justify-center mx-auto
                                ${isHtml2PdfLoaded ? 'bg-green-600 hover:bg-green-700' : 'bg-gray-500 cursor-not-allowed'}`}
                        >
                            <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M17 17h2a2 2 0 002-2v-4a2 2 0 00-2-2H5a2 2 0 00-2 2v4a2 2 0 002 2h2m2 4h6a2 2 0 002-2v-4a2 2 0 00-2-2H9a2 2 0 00-2 2v4a2 2 0 002 2zm8-12V5a2 2 0 00-2-2H9a2 2 0 00-2 2v4h10z"></path></svg>
                            Print Analysis to PDF
                        </button>

                        <div ref={contentRef} className="space-y-8 mt-8 p-4 bg-gray-800 rounded-xl"> {/* This div will be captured for PDF */}
                            {/* Processor Usage */}
                            <section className="bg-gray-700 p-6 rounded-lg shadow-md">
                                <h2 className="text-xl font-semibold mb-4 text-indigo-300" title="Estimates the computational load introduced by parallax effects over time.">
                                    Estimated Processor Usage Over Time
                                </h2>
                                <CpuUsageGraph
                                    data={analysisResults.cpuUsage.cpuPoints}
                                    markers={analysisResults.cpuUsage.journeyMarkers}
                                    detectedLayers={analysisResults.cpuUsage.detectedLayers}
                                />
                            </section>

                            {/* JS vs CSS Efficiency */}
                            <section className="bg-gray-700 p-6 rounded-lg shadow-md">
                                <h2 className="text-xl font-semibold mb-4 text-indigo-300" title="Analyzes if JavaScript-driven animations could be more efficiently handled by CSS transforms.">
                                    JavaScript vs. CSS Transforms Efficiency
                                </h2>
                                <div className="overflow-x-auto">
                                    <table className="min-w-full bg-gray-800 rounded-lg">
                                        <thead>
                                            <tr className="bg-gray-600 text-left text-gray-200 uppercase text-sm">
                                                <th className="py-3 px-4 rounded-tl-lg">Status</th>
                                                <th className="py-3 px-4">Description</th>
                                                <th className="py-3 px-4 rounded-tr-lg">Suggestion / Insight</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {analysisResults.jsVsCss.map((item, index) => (
                                                <tr key={index} className={`${index % 2 === 0 ? 'bg-gray-700' : 'bg-gray-800'} border-b border-gray-600`}>
                                                    <td className="py-3 px-4">
                                                        {item.type === 'X' && <span className="text-red-400 font-bold text-lg">✕</span>}
                                                        {item.type === 'O' && <span className="text-green-400 font-bold text-lg">✓</span>}
                                                    </td>
                                                    <td className="py-3 px-4 text-gray-300">{item.description}</td>
                                                    <td className="py-3 px-4 text-gray-400">
                                                        {item.suggestion}
                                                        {item.llmFeature && item.type === 'X' && (
                                                            <button
                                                                onClick={() => generateCodeSuggestion(item.description, item.context)}
                                                                className="ml-2 px-3 py-1 bg-purple-600 text-white text-xs rounded-full hover:bg-purple-700 transition duration-200 ease-in-out shadow-md"
                                                                disabled={llmLoading}
                                                            >
                                                                ✨ Suggest Optimization
                                                            </button>
                                                        )}
                                                    </td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                            </section>

                            {/* Accessibility */}
                            <section className="bg-gray-700 p-6 rounded-lg shadow-md">
                                <h2 className="text-xl font-semibold mb-4 text-indigo-300" title="Assesses the page's adherence to accessibility best practices for motion and readability.">
                                    Accessibility Assessment <span className="text-lg text-gray-400 ml-2">(Score: {analysisResults.accessibility.score}%)</span>
                                </h2>
                                <div className="overflow-x-auto">
                                    <table className="min-w-full bg-gray-800 rounded-lg">
                                        <thead>
                                            <tr className="bg-gray-600 text-left text-gray-200 uppercase text-sm">
                                                <th className="py-3 px-4 rounded-tl-lg">Status</th>
                                                <th className="py-3 px-4">Finding</th>
                                                <th className="py-3 px-4 rounded-tr-lg">Recommendation</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {analysisResults.accessibility.findings.map((item, index) => (
                                                <tr key={index} className={`${index % 2 === 0 ? 'bg-gray-700' : 'bg-gray-800'} border-b border-gray-600`}>
                                                    <td className="py-3 px-4">
                                                        {item.type === 'X' && <span className="text-red-400 font-bold text-lg">✕</span>}
                                                        {item.type === 'O' && <span className="text-green-400 font-bold text-lg">✓</span>}
                                                        {item.type === 'Suggestion' && <span className="text-yellow-400 font-bold text-lg">ⓘ</span>}
                                                    </td>
                                                    <td className="py-3 px-4 text-gray-300">{item.description}</td>
                                                    <td className="py-3 px-4 text-gray-400">
                                                        {item.suggestion}
                                                        {item.llmFeature && item.type === 'X' && (
                                                            <button
                                                                onClick={() => generateAccessibilityExplanation(item.description)}
                                                                className="ml-2 px-3 py-1 bg-purple-600 text-white text-xs rounded-full hover:bg-purple-700 transition duration-200 ease-in-out shadow-md"
                                                                disabled={llmLoading}
                                                            >
                                                                ✨ Explain/Suggest Fix
                                                            </button>
                                                        )}
                                                    </td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                            </section>

                            {/* Responsiveness */}
                            <section className="bg-gray-700 p-6 rounded-lg shadow-md">
                                <h2 className="text-xl font-semibold mb-4 text-indigo-300" title="Evaluates how well the parallax effects adapt to different screen sizes (desktop, tablet, mobile).">
                                    Responsiveness Assessment
                                </h2>
                                <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-center">
                                    {Object.entries(analysisResults.responsiveness).map(([device, score]) => (
                                        <div key={device} className="bg-gray-800 p-4 rounded-lg shadow-inner">
                                            <h3 className="text-lg font-semibold capitalize mb-2 text-gray-200">{device}</h3>
                                            <p className={`text-xl font-bold ${
                                                score.includes('Good') ? 'text-green-400' :
                                                score.includes('Fair') ? 'text-yellow-400' :
                                                score.includes('Poor') ? 'text-red-400' : 'text-gray-300'
                                            }`}>
                                                {score}
                                            </p>
                                        </div>
                                    ))}
                                </div>
                                <p className="text-sm text-gray-400 mt-4">
                                    <span className="font-bold text-yellow-400">Note:</span> This assessment is based on the presence of common media queries and viewport settings. Actual responsiveness should be tested across various devices.
                                </p>
                            </section>

                            {/* Mouse Parallax on Mobile */}
                            <section className="bg-gray-700 p-6 rounded-lg shadow-md">
                                <h2 className="text-xl font-semibold mb-4 text-indigo-300" title="Examines how mouse-controlled parallax effects translate to touch-based mobile devices.">
                                    Mouse Parallax Effects on Mobile
                                </h2>
                                <div className="overflow-x-auto">
                                    <table className="min-w-full bg-gray-800 rounded-lg">
                                        <thead>
                                            <tr className="bg-gray-600 text-left text-gray-200 uppercase text-sm">
                                                <th className="py-3 px-4 rounded-tl-lg">Status</th>
                                                <th className="py-3 px-4">Finding</th>
                                                <th className="py-3 px-4 rounded-tr-lg">Suggestion / Insight</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {analysisResults.mouseParallax.map((item, index) => (
                                                <tr key={index} className={`${index % 2 === 0 ? 'bg-gray-700' : 'bg-gray-800'} border-b border-gray-600`}>
                                                    <td className="py-3 px-4">
                                                        {item.type === 'X' && <span className="text-red-400 font-bold text-lg">✕</span>}
                                                        {item.type === 'O' && <span className="text-green-400 font-bold text-lg">✓</span>}
                                                        {item.type === 'Detected' && <span className="text-blue-400 font-bold text-lg">●</span>}
                                                        {item.type === 'N/A' && <span className="text-gray-400 font-bold text-lg">-</span>}
                                                    </td>
                                                    <td className="py-3 px-4 text-gray-300">{item.description}</td>
                                                    <td className="py-3 px-4 text-gray-400">{item.suggestion}</td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                            </section>

                            {/* LLM Output Section */}
                            {(llmCodeSuggestion || llmAccessibilityExplanation) && (
                                <section className="bg-gray-700 p-6 rounded-lg shadow-md">
                                    <h2 className="text-xl font-semibold mb-4 text-purple-300">
                                        ✨ Gemini AI Suggestion
                                    </h2>
                                    {llmLoading && (
                                        <div className="text-center text-purple-300 text-lg">
                                            Generating AI suggestion...
                                        </div>
                                    )}
                                    {llmCodeSuggestion && (
                                        <div className="bg-gray-800 p-4 rounded-lg overflow-x-auto text-sm text-gray-200">
                                            <pre className="whitespace-pre-wrap font-mono">{llmCodeSuggestion}</pre>
                                        </div>
                                    )}
                                    {llmAccessibilityExplanation && (
                                        <div className="bg-gray-800 p-4 rounded-lg text-sm text-gray-200">
                                            <pre className="whitespace-pre-wrap font-sans">{llmAccessibilityExplanation}</pre>
                                        </div>
                                    )}
                                </section>
                            )}
                        </div>
                    </>
                )}
            </div>
            {showHelp && <HelpModal onClose={() => setShowHelp(false)} />} {/* Render Help Modal */}
        </div>
    );
};

export default App;
